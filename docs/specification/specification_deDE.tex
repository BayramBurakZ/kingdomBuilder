\documentclass[a4paper]{scrreprt}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{ae}
\usepackage[bookmarks,bookmarksnumbered]{hyperref}
\usepackage{tabularx}


\newenvironment{requirement}[5] {
	\subsection{#1}
	\begin{tabularx}{\textwidth}{|X|l|X|X|}
		\hline
		Priorität & Zuständiger & Arbeitsaufwand & Abhängigkeiten \\
		\hline
		#2 & #3 & #4 & #5 \\
		\hline
	\end{tabularx}
	}{
	\newpage
	}


\begin{document}

% Title page
\title{Pflichtenheft}
\author{
	Bayram, Burak
	\and
	Kirsch, Julian
	\and
	Lang, Linda
	\and
	Schott, Erik
	\and
	Wegel, Tom
}
\maketitle

\newpage

% TOC
\tableofcontents
\newpage

% Intro
\chapter{Einleitung}
\section{Zweck und Ziel dieses Dokuments}

Dieses Dokument dient dem Projektmanagement. Gemäß der Art eines Pflichtenhefts bestimmt dieses Dokument Ziele, Wichtigkeit der Ziele, also ob das Ziel ein Muss-, ein Soll- oder ein Kann-Ziel ist. Des Weiteren werden die Ziele in Meilensteine gruppiert.

Jedes Ziel wurde mit dem gleichen Aufbau formuliert. Dazu wird eine Tabelle angeführt, welche Kürzel, Priorität, Abhängigkeiten von anderen Zielen, Zuständigkeiten und eine geschätzte Bearbeitungsdauer für jedes Ziel enthält.
Weiterhin besteht jedes Ziel aus einer Beschreibung, welche mit einer sogenannten User Story angeführt wird.


\section{Ziel und Zweck des Projektes}

Ziel dieses Projektes ist es einen Client zu einem gegebenem Server zu implementieren, welcher selber das Brettspiel \glqq Kingdom Builder\grqq{} implementiert.

Ein Client kann eigene Spiele erstellen und verwalten oder einem bereits erstelltem Spiel beitreten. Spiele können hierbei lokal im sog. \glqq Hot Seat\grqq{}-Modus
oder über das Netzwerk gegen andere Spieler oder Bots gespielt werden.

\section{Nicht-Ziele des Projektes}

Ziel des Projektes ist \textbf{nicht} die Implementierung eines Spieleservers.

\section{Einsatz und Umgebung}

Das Produkt ist für Endverbraucher geeignet, die einen Computer besitzen. Des Weiteren ist für die Inbetriebnahme eine Installation der \glqq Java Runtime Environment 17\grqq{} (oder neuer) erforderlich.

Für die Onlinefunktionalität wird eine Internetverbindung benötigt.

\section{Projektorganisation}
\subsection{Meilensteine}

Die Entwicklung des Projektes wird in Meilensteinen unterteilt. Dabei verfolgen die Meilensteine aufeinander aufbauende Ziele.

Der erste Meilenstein \glqq Chat Client\grqq{} dient der Umsetzung eines grundlegendes Systems, das es ermöglicht 

Der zweite Meilenstein \glqq Basis Spiel\grqq{} umfasst die Implementierung des Basisspiels, so dass Spieler eine Lobby erstellen oder einer bestehenden Lobby beitreten 
können und das Spiel gemäß der Regeln spielen können. Es wird erwartet, dass alle grundlegenden Eigenschaften umgesetzt werden. Dies umfasst sowohl die grafische Darstellung des Spiels als auch die Implementierung aller erforderlichen Spielregeln.

Der dritte und letzte Meilensteine \glqq KI\grqq{} sieht vor, dass eine künstliche Intelligenz entwickelt wird gegen die Spieler spielen können. Des Weiteren ist auch ein \glqq Hot Seat\grqq{}-Modus vorgesehen, welcher es ermöglicht mehreren Spielern gemeinsam an einem Computer zu spielen.

\subsection{Entwicklerrollen}

Innerhalb des Projektes nimmt jeder Teilnehmer eine spezifische Rolle an und ist somit Verantwortlicher und Ansprechpartner für einen Teilbereich des Projektes:

\begin{description}
	\item[Build-Master (Julian Kirsch)] ist verantwortlich für das Einrichten, Verwalten und Pflegen des Gradle Projekts. 
						 Diese Person sorgt dafür, dass das gesamte Projekt mittels Gradle gebaut werden kann.
						 Ansprechpartner für alles, was mit den Bauen des Projektes zu tun hat.
	\item[Design-Pattern-Master (Linda Lang)] hat die Aufgabe den Einsatz von Entwursmustern an allen Teilen des Projektes zu prüfen und den jeweiligen Modul-Mitgliedern bei der
							    Umsetzung zu helfen.
	\item[Dokumentation-Master (Tom Weggel)] ist dafür verantwortlich, dass alle relevanten (insbesondere alle sichtbaren) Methoden, Funktionen, Konstanten, etc. mittels JavaDoc
							       dokumentiert  werden und diese auf dem neuesten Stand sind.
	\item[Interface-Master (Erik Schott)] ist für die Schnittstellen zwischen den einzelnen Module verantwortlich und klärt Anforderungen, Umfang und Funktion der einzelnen Komponenten 
						      des Softwareprojekts.
	\item[Test-Master (Burak Bayram)] entscheidet was getestet werden soll und sorgt dafür, dass die Tests geschrieben werden.
\end{description}

\subsection{Benutzerrollen}

Dieses Dokument beschreibt Ziele anhand von drei Benutzerrollen. Erstere ist die Rolle des \textbf{Spielers}, welcher, wie der Name schon andeutet, der Konsument des Spiels ist und mit dem
Produkt interagiert.

Die zweite Rolle, nämlich der \textbf{Root Spieler} (kurz: Root), bezieht sich auf Spieler, welche einen eigenen Spieleserver betreiben. Im Gegensatz zu normalen Spielern hat der Root administrative Freigaben und kann bspw. Spieler vom Server \glqq kicken\grqq{}.

Zuletzt gibt es die Rolle des \textbf{Entwicklers}, welcher aktiv das hier spezifizierte Produkt entwickelt.

\subsection{Arbeitsweise}
Im Folgenden sind Arbeitsweisen festgelegt, die für alle teilnehmende Entwickler verpflichtend sind.

\subsubsection{Branches}
Zu jedem Zeitpunkt im Projekt existieren zwei Branches, nämlich \glqq master\grqq{} sowie \glqq development\grqq{}. Der master-Branch stellt den aktuellsten Zustand des Projektes \textbf{nach} Abschließen eines Meilensteins dar. Der development-Branch hingegen spiegelt den aktuellsten Entwicklungsstand wider.

Des Weiteren soll, sofern semantisch sinnvoll, für jedes Ziel, das bearbeitet wird, ein eigener, sog. \glqq Feature-\grqq{}Branch erstellt werden.

Die Branches werden der \glqq GitFlow\grqq{}-Methode folgend benannt.

\subsubsection{Pull Requests}
Ist die Entwicklung eines Zieles abgeschlossen, so muss ein \glqq Pull Request\grqq{} angelegt und von den jeweiligen Test- sowie Dokumentation-Master auf Vollständigkeit geprüft.

\subsubsection{Code Style}
Der Code Style ist strikt an den Java Konventionen gehalten. Die GUI-Elemente werden der SnakeCase-Konvention folgenden notiert und mit einem FXML-Tag versehen.

Des Weiteren muss folgende Reihenfolge der Elemente innerhalb einer Klasse eingehalten werden:
\begin{itemize}
	\item Statische Variablen
	\item Instanzvariablen
	\item Konstruktoren
	\item Methoden
	\item Setter
	\item Getter
\end{itemize}

\subsubsection{Unit Test Style}
Unit Tests werden pro Klasse mit JUnit 5 durchgeführt, wobei einzelne Testklassen, soweit es möglich ist, unabhängig voneinander sein müssen, damit fehlgeschlagene Tests eindeutig einer Klasse zugeordnet werden können.

Objekte aus anderen Klassen, die zum testen benötigt werden als Member innerhalb der Testklasse aufgeführt und mittels einer Methode, die mit "@BeforeEach" annotiert ist, instanziiert.

Es müssen alle Methoden außer \glqq Getter\grqq{} und \glqq Setter\grqq{} getestet werden.

Wenn in einer Testmethode mehrere Assertions vorhanden sind, müssen diese mit der überladenen Funktion auch eindeutig benannt werden, damit bei einem fehlgeschlagenen Test auf eine Assertion zurückgeführt werden kann. Darüber hinaus sollen mehrere Assertions nur dann verwendet werden, wenn diese alle im gleichen Kontext stehen bzw. auf die selbe Art und Weise getestet werden.

Testklassen werden mit \glqq[KlassenName]Test\grqq{} und Testmethoden mit \\ \glqq test[FeatureName][optionalerSpezialFall]\grqq{} benannt.





\chapter{Ziele}
\section{Meilenstein: Chat Client}


\begin{requirement}{Grundaufbau der Programmarchitektur}{Hoch}{JK}{2h}{}

\begin{center}
	Als Entwickler möchte ich einen Grundlage für das Programm schaffen.
\end{center}

Hierbei soll eine Software-Komponente entwickelt werden, welche das Redux-Architekturmuster, samt \glqq Store\grqq{}, \glqq State\grqq{}, \glqq Reducer\grqq{} und \glqq Actions\grqq{} umsetzt. Diese Software-Komponente fungiert als Kern der Anwendung und stellt auch die Schnittstelle zwischen den verschiedenen Komponenten der Software dar.

\end{requirement}


\begin{requirement}{Spielerliste}{Hoch}{ES, TW}{4h}{}

\begin{center}
Als Spieler möchte ich mir andere Spieler anzeigen lassen, die mit dem Server verbunden sind.
\end{center}

Hierbei muss eine GUI-Komponente erstellt werden, welche alle aktuell mit dem Server verbundenen Spieler auflistet.

Durch eine Markierung in der Auflistung müssen Spieler für eine Direktnachricht auswählbar sein. Des Weiteren muss ein Button zur Verfügung stehen, welcher die Markierung wieder aufhebt.
\\
\\
TODO: GUI SKIZZE

\end{requirement}


\begin{requirement}{Chat-Log}{Hoch}{ES, TW}{20h}{}

\begin{center}
Als Spieler möchte ich mit anderen Clients per Textnachricht kommunizieren und diese angezeigt bekommen.
\end{center}

Hierbei muss eine GUI-Komponente implementiert werden, welche ein- und ausgehende Nachrichten in chronologischer Reihenfolge anzeigt.

Des Weiteren muss das versenden von lokalen Nachrichten, sofern der Spieler einem Spiel beigetreten ist, an eine Lobby, sowie das Versenden von direkt adressierten und \glqq globalen\grqq{} Nachrichten an alle Spielern auf den Server ermöglicht werden.

Nachrichten müssen visuell in sofern von einander differenziert werden, so dass...
\begin{itemize}
	\item ...Sender- bzw. Empfängernamen \textbf{fett} angezeigt werden.
	\item ...Nachrichten je nach Art (zum Beispiel Textnachricht oder Statusnachricht) farblich gekennzeichnet sind.
\end{itemize}
\end{requirement}


\begin{requirement}{Chat-Eingabe}{Hoch}{ES, TW, BB}{5h}{}

\begin{center}
	Als Spieler möchte Textnachrichten für den Chat verfassen um mit anderen Spielern zu kommunizieren.
\end{center}

Eine GUI-Komponente muss implementiert werden, die es ermöglicht Spieler per Tastatureingabe Text einzutippen. Weiter muss über Buttons die verfasste Nachricht \glqq global\grqq{} also serverweit/lobbyweit als auch an ausgewählte Spieler versendbar sein.

\end{requirement}


\begin{requirement}{Anzeigen von Statusnachrichten}{Mittel}{ES, TW}{3h}{}

\begin{center}
	Als Spieler möchte ich benachrichtigt werden, wenn ich oder ein anderer Spieler den Server verlassen.
\end{center}

Hierbei muss der Chat-Log erweitert werden, so dass Statusnachrichten angezeigt werden.

\end{requirement}


\begin{requirement}{Spielprotokoll De-/Serialisieren}{Hoch}{JK}{20h}{-}

\begin{center}
	Als Entwickler möchte ich Nachrichten de-/serialisieren um mit denen Programmieren zu können.
\end{center}

Hierbei muss eine Software-Komponente entwickelt werden, welche Nachrichten vom Server in eine Objektpräsentation und Befehle an den Server von der Objektpräsentation in Textform 
überführt. Hierfür müssen Nachrichten bzw. Befehle für folgende Aktionen oder Ereignisse unterstützt werden:
\begin{itemize}
	\item Ein- und Ausloggen des Spielers
	\item Abfrage der aktuellen Spieler
	\item Benachrichtigung über Beitritt/Verlassen eines Spielers
	\item Versenden einer Nachricht
	\item Empfangen einer Nachricht
\end{itemize}
\end{requirement}


\begin{requirement}{Verbindungsaufbau}{Hoch}{JK}{5h}{-}

\begin{center}
	Als Entwickler möchte ich eine Verbindung zu einem Spieleserver aufbauen um Befehle zu versenden, Benachrichtigungen empfangen und auf diese reagieren können.
\end{center}

Hierbei muss eine Software-Komponente entwickelt werden, welche eine aktive Netzwerkverbindung aufbaut.

\end{requirement}


\begin{requirement}{Namenseingabe}{Hoch}{ES, TW}{1h}{}

\begin{center}
	Als Spieler möchte ich meinen eigenen Namen auswählen, der anderen Spielern angezeigt wird.
\end{center}

Hierbei muss eine GUI-Komponente erstellt sowie die Netzwerk-Komponente erweitert werden, so dass ein Nutzer seinen Wunschnamen angeben und sich auf dem Server einloggen kann.

\end{requirement}


\begin{requirement}{Verbindung beenden}{Hoch}{Julian Kirsch}{3h}{}

\begin{center}
	Als Entwickler möchte ich eine bestehende Verbindung zum Server trennen um entweder das Programm zu beenden oder um auf andere Server beitreten zu können.
\end{center}

Hierbei muss die Netzwerk-Komponente erweitert werden, so dass diese den aktuellen Spieler vom Server ausloggt und die Verbindung schließt.

\end{requirement}


\section{Meilenstein: Basis Spiel}


\begin{requirement}{Hauptmenü-Maske (MainView)}{Hoch}{TW}{2h}{-}

\begin{center}
	Als Spieler möchte ich die Möglichkeit haben ein lokales Spiel zu starten, mich mit einem Spieleserver zu verbinden und die Programmeinstellungen zu ändern.
\end{center}


Hierbei muss eine GUI-Maske entworfen und implementiert werden, die folgende Buttons zur Verfügung stellen muss:
\begin{description}
	\item[Local Game] öffnet die Maske zur erstellen eines Spiels (\glqq GameSettingsView\grqq{}).
	\item[Online Game] öffnet die Maske zur Initiierung einer neuen Netzwerkverbindung (\glqq ServerConnectView\grqq{}), sofern mann nicht schon verbunden ist.
				Ansonsten wird direkt die Maske mit dem Spielbrowser (\glqq GameBrowserView\grqq{}) geöffnet.
	\item[Settings] öffnet die Einstellungs-Maske (\glqq ApplicationSettingsView\grqq{}).
	\item[Exit] beendet das Programm.
\end{description}

\end{requirement}


\begin{requirement}{Einstellungs-Maske (ApplicationSettingsView)}{TW}{5h}{-}

\begin{center}
	Als Spieler möchte ich die Möglichkeit haben die Einstellungen des Programms zu ändern um dieses an meine Anforderungen anzupassen.
\end{center}

Hierbei muss eine GUI-Maske entworfen und implementiert werden, die es einem ermöglicht die Präferenz aus einer Auswahl von verfügbaren Sprachen sowie den eigenen bevorzugten Namen zu setzen. Des Weiteren müssen zwei Buttons zur Verfügung gestellt werden, welche es ermöglichen die Änderungen anzuwenden oder direkt in die Hauptmenü-Maske \glqq MainView\grqq{} zu wechseln.

\end{requirement}


\begin{requirement}{Verbindungs-Maske (ServerConnectView)}{Hoch}{TW}{2h}{-}

\begin{center}
	Als Spieler möchte ich mich unter Angabe einer IP-Adresse zu einem Spieleserver verbinden.
\end{center}

Hierbei muss eine GUI-Maske entworfen und implementiert werden, die einem die Eingabe einer IP-Adresse ermöglicht. Weiter sollen auch zwei Buttons "Verbinden" und "Zurück" zur Verfügung stehen.

Wird der Button \glqq Verbinden\grqq{} geklickt, so wird eine Verbindung erstellt und der Nutzer zum Gamebrowser (\glqq GameBrowserView\grqq{})  geführt. Schlägt die Verbindung fehl, so wird der Nutzer über einen Dialog über den Fehler informiert.
Wird der Button \glqq Zurück\grqq{} geklickt, so wird der Nutzer zurück zum Hauptmenü (\glqq MainView\grqq{}) geführt.

\end{requirement}



\begin{requirement}{Gamebrowser (GameBrowserView)}{Hoch}{LL, TW}{7h}{-}

\begin{center}
	Als Spieler möchte ich ein Spiel erstellen oder beobachten oder einem Spiel beitreten.
\end{center}

Hierbei muss eine GUI-Maske entworfen und implementiert werden, die alle Spiele des aktuellen Servers auflistet sowie einem Spieler ermöglicht ein Spiel zu erstellen.

Es werden alle aktuell laufenden Spiele auf dem Server, zu dem der Client verbunden ist, angezeigt. Diesen Spielen kann als Spieler beigetreten werden, wenn sie nicht bereits voll besetzt sind. Es kann stets einem Spiel als Zuschauer beigetreten werden. Es kann außerdem ein neues Spiel erstellt werden.

In der oberen linken Ecke befinden sich 3 Buttons. Der erste Button \glqq Zurück \grqq{} sorgt dafür, zurück in das Hauptmenü (\glqq MainView \grqq{}) zu kommen. 
Daneben befindet sich ein Button \glqq Refresh \grqq{}, um die Tabelle manuell zu aktualisieren.
Hierneben ist eine ComboBox, mit der man in der Tabelle nach einem gewissen Spiel-Zustand filtern kann. Nach der Auswahl wird die Tabelle anhand der Auswahl angepasst.
Die laufenden Spiele werden in einer TableView angezeigt. Diese besitzt eine Spalte für den Namen des Spiels, die Anzahl der Spieler und den Status, ob das Spiel auf Spieler wartet, läuft oder beendet ist.

Auf der rechten Seite werden detaillierte Informationen zu dem in der Tabelle ausgewählten Spiel angezeigt. Diese Informationen bestehen aus dem Namen des Spiels, wer der Host des Spiels ist, dem eingestelltem Zeit- und Zuglimit. Anschließend folgt eine TextArea, die die Beschreibung des Spiels anzeigt.
Die Informationen werden mit einer GridPane gegliedert.

In der untersten Zeile befinden sich drei Buttons. 
Der erste Button sorgt dafür, dass ein User ein Spiel erstellt und die View zu den Spiel-Settings wechselt.
Mit dem Button daneben betritt der User das in der Tabelle ausgewählte Spiel. Die aktuelle View wird zur View geändert, die das Spiel anzeigt.
Der letzte Button sorgt dafür, dass der User dem in der Tabelle ausgewählten Spiel als Zuschauer beitritt. Hierbei wird die View auch zur View geändert, die das Spiel anzeigt.

\end{requirement}


\begin{requirement}{Spieleinstellungen (GameSettingsView)}{Hoch}{BB, TW, LL}{3h}{-}

\begin{center}
	Als Spieler möchte ich die Einstellungen für Spiel an meine Wünsche anpassen.
\end{center}

Hierbei soll eine GUI-Maske entworfen und implementiert werden, die einem Spieler ermöglichen folgende Einstellungen zu setzen:

\begin{itemize}
	\item Zeitlimit
	\item Zuglimit
	\item Maximale Spielerzahl
	\item Bots
\end{itemize}

Des Weiteren müssen Buttons angeboten werden, die einem ermöglichen das Spiel zu \glqq hosten\grqq{} und die Spieleinstellungen zu verlassen.
Wird der Button \glqq 
Hosten\grqq{} geklickt, so wird das Spiel erstellt und der Ersteller tritt automatisch bei. Anschließend wird der Spieler in die Spielinformations-Maske (\glqq GameInfoView\grqq{}) geführt. Wird der Button \glqq Zurück\grqq{} gedrückt, so wird der Spieler zurück in das Hauptmenü (\glqq MainView\grqq{}) geführt.

\end{requirement}


\begin{requirement}{Spielinformationen (GameInfoView)}{Hoch}{TW}{6h}{-}

\begin{center}
	Als Spieler möchte ich Information über das aktuell beigetretene Spiel einsehen.
\end{center}

Hierbei muss eine GUI-Maske entworfen und implementiert werden, welche relevante Informationen über das aktuelle Spiel anzeigt.

Diese werden in zwei Bereiche unterteilt. Zunächst werden folgende Informationen angezeigt:
\begin{itemize}
	\item Anzahl der vergangenen Züge
	\item Zeitlimit
	\item Zuglimit
	\item Siegbedingung
	\item Spielerinformationen (Name, verbleibende Siedlungen, Punkte, optional auch Farbe)
\end{itemize}

Außerdem soll das Spielfeld, die Tokens und Anzahl der Auswählbaren Hexagone angezeigt werden.

\end{requirement}



\begin{requirement}{Spielbrett (GameView)}{Hoch}{TW, LL}{30h}{}
	
\begin{center}
	Als Spieler möchte ich das Spielbrett visuell dargestellt bekommen.
\end{center}

Hierbei muss eine GUI-Komponente dargestellt werden, welche alle Hexagone gemäß dem aktuellen Spielfortschitts darstellt. Des Weiteren müssen Interaktionen implementiert werden,
so dass die Karte bewegt und vergrößert sowie verkleinert werden kann. Es gilt zu beachten, dass Spieler die Karte nicht über den Rand hinaus bewegen dürfen sowie das Grenzen für das Verkleinern und Vergrößern der Karte gesetzt werden.

Die Karte muss über die Pfeiltasten bewegbar sein und über das Mausrad vergrößert oder verkleinert werden können.

\end{requirement}


\begin{requirement}{Spielregeln}{Hoch}{ES, BB}{16h}{-}

\begin{center}
	Als Entwickler möchte überprüfen ob eine antizipierter Spielzug gültig ist um fehlerhafte Züge zu unterbinden.
\end{center}

Hierbei soll eine Komponente entwickelt werden, welche anhand des aktuellen Spielfortschritts überprüft ob der nächste Zug zulässig ist.
Ist der Zug unzulässig, so soll dieser Unterbunden werden.

\end{requirement}


\begin{requirement}{Spielbrett 2 (GameView)}{Hoch}{TW}{10h}{}

\begin{center}
	Als Spieler möchte ich Züge auf dem Brett ausführen können um das Spiel zu spielen.
\end{center}

Ist auf einem Feld eine Siedlung platziert, so wird diese Siedlung auf dem Feld mit der entsprechenden Spielerfarbe gezeichnet. 

Markierungen:
Zu Beginn eines Zuges werden die Hexagone markiert, auf denen eine Siedlung entsprechend des Basiszugs platziert werden kann. Wird ein Token ausgewählt, so verändern sich die Markierungen zu den Feldern, auf denen der entsprechende Token angewendet werden kann. Beim Aufheben der Token-Auswahl ändern sich die Markierungen wieder zu den zuvor markierten Feldern. Wurde der Basiszug schon getätigt, wird nichts mehr markiert.

Basiszug:
Wenn der Spieler nicht bereits alle Siedlungen für die Runde platziert hat, so kann er einen Basiszug tätigen, wobei eine Siedlung ohne Verwendung von Token platziert wird.
Wird nicht ein Token in der Schaltfläche ausgewählt und ein Hexagon des Terrain Typs der Runde angeklickt, wird geprüft, ob dies ein zulässiges Feld ist. Ist dies ein valides Feld, so wird eine Siedlung platziert. Ansonsten bekommt der Spieler eine Mitteilung, dass dies kein valides Feld ist.

Terrain Karte:
Am unteren Bildschirm befindet sich eine Anzeige, welche durch ein Bild und eine Beschreibung anzeigt, welche Terrain Karte gerade im Zug ausgewählt wurde. Diese wird jede Runde aktualisiert.

Token:
Um einen Token zu verwenden, kann dieses an der unteren Schaltfläche neben der Terrain Karte angeklickt werden. Wenn ein Token ausgewählt ist, werden andere eigene Tokens ausgegraut und deaktiviert. Dem Spieler wird anschließend durch ein Highlight gezeigt, welche Züge möglich sind und bei Bedarf können diese durchgeführt oder die Token-Auswahl abgebrochen werden, indem das Token erneut angeklickt wird.
Die Tokens werden deaktiviert, wenn der Client nicht am Zug ist. Zudem werden diese neu angezeigt, wenn sich der Hotseat Spieler wechselt.

Zum Verschieben einer Siedlung mittels Token wird die Siedlung zunächst ausgewählt und anschließend das neue Hexagon angeklickt.

Updates bei Änderungen:
Bei Zügen anderer Clients wird die Kamera der Karte zu dem Feld bewegt, bei welchem sich etwas verändert hat.


\end{requirement}



\begin{requirement}{Überarbeitung und Abschließung des Netzwerks}{Hoch}{JK, LL}{40h}{-}

\begin{center}
	Als Entwickler möchte ich alle Befehle und Benachrichtigungen des zur Verfügung gestelllten Server nutzen können.
\end{center}

Hierbei soll die Netzwerk-Komponente überarbeitet werden, so dass alle Benachrichtigungen und Befehle unterstützt werden. 

\end{requirement}


\section{Meilenstein: KI und Feinschliff}


\begin{requirement}{Vollständige Integration mit dem Netzwerk-Modul}{Hoch}{JK, LL}{10h}{-}

\begin{center}
	Als Spieler möchte ich mit meinen Freunden über das Netzwerk als auch lokal am selben PC gegen KIs spielen.
\end{center}

Hierbei soll das Netzwerk-Modul umfangreich integriert werden, so dass mehrere Spieler gemeinsam über das Netzwerk an einem Spiel teilnehmen können. Hier soll auch die Möglichkeit beachtet werden, dass KIs auch als Spieler teilnehmen. Des Weiteren soll der Hot-Seat-Modus implementiert werden, so dass mehrere Spieler am selben PC gegeneinander und gegen Spieler über das Netzwerk spielen können.

\end{requirement}


\begin{requirement}{Siegesbedingung für Bots}{Hoch}{alle}{30h}

\begin{center}
Ich als Entwickler möchte für Bots die Siegesbedingungen zur Verfügung stellen.
Ich als Spieler möchte meinen aktuellen Punktestand wissen.
\end{center}

Hierbei muss zwischen den 10 Siegesbedingungen unterschieden werden:
\begin{description}
	\item[Fischer] Prüft, wie viele Siedlungen angrenzend an Wasser-Feldern gebaut wurden. Pro Siedlung bekommt der Spieler, dem die Siedlung gehört, einen Punkt. Nicht beachtet werden Siedlungen, welche direkt auf Wasser liegen.
	\item[Bergleute] Prüft, wie viele Siedlungen angrenzend an Bergen gebaut wurden. Pro Berg bekommt ein Spieler einen Punkt, egal wie viele Siedlungen der Spieler an diesem Berg besitzt.
	\item[Händler] Prüft, ob ein Spieler ein oder mehrere Orts-/Burgfelder durch eigene Siedlungen verbunden hat.
	\item[Arbeiter] Prüft für jedes Orts-/Burgfeld, wie viele Siedlungen angrenzen. Pro Siedlung erhält der Spieler einen Punkt.
	\item[Entdecker] Pro Horizontaler Linie auf dem Spielbrett mit mindestens einer Siedlung bekommt der zugehörende Spieler einen Punkt.
	\item[Ritter]  Für jeden Spieler wird die horizontale Linie des Spielbretts mit seinen meisten Siedlungen ermittelt. Für jede Siedlung auf dieser Linie bekommt der Spieler 2 Punkte.
	\item[Einsiedler] Es wird 1 Punkt für jedes separate Siedlungsgebiet pro Spieler vergeben. Ein Siedlungsgebiet wird definiert durch eine Menge von angrenzenden Siedlungen.
	\item[Lords] Pro Quadrant werden Punkte vergeben. Spieler mit den meisten Siedlungen erhalten 12 Punkte. Spieler mit den zweitmeisten Siedlungen erhalten 6 Punkte.
	\item[Bürger] Jeder Spieler erhält 1 Punkt für je 2 seiner Siedlungen in seinem größten Siedlungsgebiet.
	\item[Bauern] Jeder Spieler erhält 3 Punkte für jede Siedlung in dem Quadranten, in dem er die wenigsten Siedlungen besitzt. Bei 2 Quadranten mit der gleichen geringsten 
\end{description}

\end{requirement}


\begin{requirement}{Bots}{Hoch}{Alle}{20h}{}

\begin{center}
Ich als Spieler möchte Bots zu meinem Spiel hinzufügen und somit jederzeit beliebig viele Gegenspieler für mein Spiel haben können.
\end{center}

Ermittlung strategisch günstiger Züge mittels der bereitgestellten Funktionen in der Spiellogik.

Dies erfolgt, indem mittels der Win Conditions der Zug geplant wird. Die Berechnung erfolgt in jedem Zug, da Vorausschauen nicht funktioniert, weil zukünftige Karten unbekannt sind.

Das Ziel liegt darin, den Spielzug zu optimieren und die meisten Punkte zu bekommen. Dabei werden alle möglichen platzierbaren Felder betrachtet und das beste Feld ausgesucht. In diesem Moment wird jedoch noch keine Siedlung platziert, sondern die Felder angeschaut, die nun möglich sind. Dies wird in einem Graphen aufgenommen. Hiernach werden eine oder mehrere Alternativen betrachtet, damit die KI prüft, ob die erste Siedlung wo anders platziert werden kann, damit die Punkte maximiert werden können. Alle Alternativen werden in dem Graphen aufgenommen und letztendlich der beste Zug ausgewählt und durchgeführt. Dieses Konzept ist bekannt unter dem Namen Zielorientierte Aktionsplanung (GOAP).

Die optionale Schwierigkeitseinstellung wird umgesetzt, in dem die KI für Ihre Planung für den Zug lediglich eine Teilmenge der Win Conditions auswählt. Die anspruchsvolle KI wird anhand aller Win Conditions ihren Zug planen.

Ein Bot wird mit Hilfe eines internen Client implementiert, der erstellt wird, wenn in den Spieleinstellungen ein Bot ausgewählt wird. Es wird für jeden Bot ein eigenes Client Objekt erstellt, damit dieser ein eigenen Socket zum Server besitzt und somit auch eine eigene ID. Dies ist notwendig, damit ein Bot eigene Spielzüge unabhängig vom User Client durchführen kann.

\end{requirement}


\begin{requirement}{Dekorationen}{Mittel}{tba.}{10h}{}

\begin{center}
	Als Entwickler möchte ich eine \glqq schöne \grqq{} GUI haben um den Spieler das Spiel schmackhaft zu machen.
\end{center}

Dieses Ziel befasst sich mit dem Design der GUI. Hierbei sollen GUI-Element dekoriert und angepasst werden. Dies erfolgt unter Anderem durch die Auswahl geeigneter Farben, Schriftarten und Formen sowie Anpassungen am Layout.


\end{requirement}


\begin{requirement}{Animationen}{Gering}{tba.}{10h}{}

Hierbei sollen Züge anschaulicher über Animationen dargestellt werden. Dabei werden insbesondere die Veränderungen am Spielbrett wie z.B. das Platzieren oder Verschieben von Siedlungen flüssig und klar verfolgbar animiert.

Optional können Wolken animiert dargestellt werden, welche sich über das Feld bewegen.

\end{requirement}


\begin{requirement}{3D-Darstellung}{Gering}{tba.}{8h}{}

Hierbei soll das Spiel nicht mehr durch einfach 2D-Bilder sondern durch einfache 3D-Modelle dargestellt werden.

\end{requirement}

\begin{requirement}{Benutherhandbuch}{Mittel}{alle}{10h}{}

Erstellen eines Benutzerhandbuchs, welche dem Endanwender die Bedienung der Anwendung näher erklärt. 

Der Design-Stil wird anhand unseres Programm-Stils gewählt und anschaulich mit Bildern dargestellt.

Dies wird wie im Lastenheft als Portable Document Format (pdf) in der Papiergröße DIN A5 erstellt.

\end{requirement}


\chapter{Anhang}
\section{Architektur: Redux}
Die Redux Architektur besitzt verschiedene Bereiche. Es existiert der Store, mehrere Reducers, die Views und Actions.

Der Mittelpunkt ist hierbei der Store. In Redux existiert immer nur ein Store-Objekt. Dieser beinhaltet den State des ganzen Programms. Dies hat den Vorteil, dass alle Daten des Programms an einem Ort gespeichert sind und Undo und Redo Funktionen leichter umzusetzen sind. Hierbei ist jedoch zu beachten, dass Funktionen nur Leserechte auf den State haben und keine Schreibrechte.
Hier kommen die Actions in Einsatz. Interagiert der Nutzer mit der View, wird eine Action erstellt und dem Dispatcher des Stores übergeben. Dieser ruft den Reducer mit dem State und der Action auf. Nur der Reducer kann nun anhand der Action den State verändern.

Wenn der Reducer erfolgreich den State verändert hat, werden anhand der Änderung Methoden aufgerufen, die die View updaten. Dabei schreibt sich die View beim Initialisieren in eine OnChange-Methode ein und teilt dieser mit, welche Methoden aufgerufen werden müssen, wenn eine Änderung vorliegt.


\section{Glossar}
\begin{description}
	\item[Action] Objekt anhand dessen der State/Store der Application aktualisiert wird.
	\item[Application] Anwendung auf der das Spiel abläuft.
	\item[Assertion] Wird bei Tests verwendet um einen erwarteten Wert mit einem tatsächlichen zu Vergleichen.
	\item[Basiszug] Platzieren der 3 Siedlungen auf dem gegebenen Feldtyp. Pflichtaktion pro Zug.
	\item[Benutzer] Anwender des Programms.
	\item[Bonuszug] Zusätzliche Aktion, wie Platzierung einer Siedlung auf einem vorgeschriebenen Feld oder Verschieben bereits gesetzter Siedlungen.
			     Ausgelöst werden diese durch die Verwendung von Tokens.
	\item[Bots]	     Computer (Künstliche Intelligenz) die anstelle eines Menschen spielt.
\end{description}


\end{document}
